import os
import pypyrus_logbook as logbook
import pypyrus_tables as tables
import sqlalchemy as sql

from .conf import make_config


class Database():
    """This class represents application Database. It used to store all data
    generated by Runner like job schedule and history, scheduler status,
    auditing etc.

    Parameters
    ----------
    config : pypyrus_runner.conf.Config, optional
        The argument is used as Configurator from which connection URL is taken.
        Implemented to not generate multiple configurators in one sesssion.
        Will depreciate in futher versions when configurator will be stored
        in memory.

    Attributes
    ----------
    log : pypyrus_logbook.logger.Logger
        Main application logger.
    config : pypyrus_runner.conf.Config
        Main application configurator.
    schedule : sqlalchemy.schema.Table
        Table with job schedule.
    history : sqlalchemy.schema.Table
        Table with job history.
    status : sqlalchemy.schema.Table
        Table with scheduler status.
    audit : sqlalchemy.schema.Table
        Table with schedule audit.
    modified : bool or None
        The attribute represents schedule modification state like insert,
        delete, update that is tracking by audit. It will return True if last
        known modification date will differ from that can be found in audit.
        Used to immediate refresh of schedule if it was changed instead of
        loading it every new second.
    """

    def __init__(self, config=None):
        self.log = logbook.getlogger()
        self.config = config or make_config(read_only=True)

        self._path = os.path.abspath(self.config.general['db'])
        credentials = f'sqlite:///{self._path}'
        self._engine = sql.create_engine(credentials)
        self._metadata = sql.MetaData()
        self._connection = self._engine.connect()

        self._schedule = self._make_schedule()
        self._history = self._make_history()
        self._status = self._make_status()
        self._audit = self._make_audit()
        self._mtime = None
        pass

    @property
    def path(self):
        """Getter for `path` attribute."""
        return self._path

    @property
    def connection(self):
        """Getter for `modified` attribute."""
        return self._connection

    @property
    def schedule(self):
        """Getter for `schedule` attribute."""
        return self._schedule

    @property
    def history(self):
        """Getter for `history` attribute."""
        return self._history

    @property
    def status(self):
        """Getter for `status` attribute."""
        return self._status

    @property
    def audit(self):
        """Getter for `audit` attribute."""
        return self._audit

    @property
    def modified(self):
        """Getter for `modified` attribute."""
        select = sql.select([sql.func.max(self._audit.c.event_time)])
        mtime = self.connection.execute(select).scalar()
        if mtime is None:
            return False
        elif self._mtime == mtime:
            return False
        else:
            self._mtime = mtime
            return True

    def _make_schedule(self):
        """Create or load schedule table.

        Return
        ------
        table : sqlalchemy.schema.Table
            Table API object.
        """
        name = 'schedule'
        if self._engine.has_table(name) is True:
            table = sql.Table(name, self._metadata,
                              autoload=True, autoload_with=self._engine)
            return table
        else:
            table = sql.Table(
                name, self._metadata,
                sql.Column('id', sql.Integer, primary_key=True),
                sql.Column('name', sql.String),
                sql.Column('description', sql.String),
                sql.Column('environment', sql.String),
                sql.Column('file', sql.String),
                sql.Column('month_day', sql.String(2)),
                sql.Column('week_day', sql.String(2)),
                sql.Column('hour', sql.String(2)),
                sql.Column('minute', sql.String(2)),
                sql.Column('second', sql.String(2)),
                sql.Column('parameters', sql.String),
                sql.Column('status', sql.String(1)))
            table.create(self._engine)
            self.log.info(f'Table <{name}> created.')
            return table

    def _make_history(self):
        """Create or load history table.

        Return
        ------
        table : sqlalchemy.schema.Table
            Table API object.
        """
        name = 'history'
        if self._engine.has_table(name) is True:
            table = sql.Table(
                name, self._metadata,
                autoload=True, autoload_with=self._engine)
            return table
        else:
            table = sql.Table(
                name, self._metadata,
                sql.Column('id', sql.Integer, primary_key=True),
                sql.Column('job', sql.Integer),
                sql.Column('initiator', sql.String),
                sql.Column('log', sql.String),
                sql.Column('pid', sql.Integer),
                sql.Column('start_date', sql.DateTime),
                sql.Column('end_date', sql.DateTime),
                sql.Column('status', sql.String(1)),
                sqlite_autoincrement=True)
            table.create(self._engine)
            self.log.info(f'Table <{name}> created.')
            return table

    def _make_status(self):
        """Create or load status table.

        Return
        ------
        table : sqlalchemy.schema.Table
            Table API object.
        """
        name = 'status'
        if self._engine.has_table(name) is True:
            table = sql.Table(
                name, self._metadata,
                autoload=True, autoload_with=self._engine)
            return table
        else:
            table = sql.Table(
                name, self._metadata,
                sql.Column('start_date', sql.DateTime),
                sql.Column('end_date', sql.DateTime),
                sql.Column('pid', sql.Integer))
            table.create(self._engine)
            self.log.info(f'Table <{name}> created.')
            return table

    def _make_audit(self):
        """Create or load audit table.

        Return
        ------
        table : sqlalchemy.schema.Table
            Table API object.
        """
        name = 'audit'
        if self._engine.has_table(name) is True:
            table = sql.Table(
                name, self._metadata,
                autoload=True, autoload_with=self._engine)
            return table
        else:
            table = sql.Table(
                name, self._metadata,
                sql.Column('event_time', sql.DateTime),
                sql.Column('event_type', sql.String))
            table.create(self._engine)
            triggers = []
            triggers.append([
                r"CREATE TRIGGER check_schedule_delete AFTER DELETE",
                r"ON schedule",
                r"BEGIN",
                r"INSERT INTO audit (event_time, event_type)",
                r"VALUES (datetime(), 'DELETE');",
                r"END"])
            triggers.append([
                r"CREATE TRIGGER check_schedule_insert AFTER INSERT",
                r"ON schedule",
                r"BEGIN",
                r"INSERT INTO audit (event_time, event_type)",
                r"VALUES (datetime(), 'INSERT');",
                r"END"])
            triggers.append([
                r"CREATE TRIGGER check_schedule_update AFTER UPDATE",
                r"ON schedule",
                r"BEGIN",
                r"INSERT INTO audit (event_time, event_type)",
                r"VALUES (datetime(), 'UPDATE');",
                r"END"])
            for trigger in triggers:
                stmt = '\n'.join(trigger)
                self._connection.execute(stmt)
            self.log.info(f'Table <{name}> created.')
            return table
